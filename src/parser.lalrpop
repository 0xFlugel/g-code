use crate::ast;
use crate::lexer;
use lexer::LexicalError;
use num_rational::Ratio;

grammar<'input>(input: &'input str);

extern {
    type Location = usize;
    type Error = LexicalError;

    enum lexer::LexTok<'input> {
        TokNewline => lexer::LexTok::Newline,
        TokDot => lexer::LexTok::Dot,
        TokStar => lexer::LexTok::Star,
        TokMinus => lexer::LexTok::Minus,
        TokString => lexer::LexTok::String(<&'input str>),
        TokInlineComment => lexer::LexTok::InlineComment(<&'input str>),
        TokComment => lexer::LexTok::Comment(<&'input str>),
        TokInteger => lexer::LexTok::Integer(<&'input str>),
        TokLetters => lexer::LexTok::Letters(<&'input str>),
        TokWhitespace => lexer::LexTok::Whitespace(<&'input str>)
    }
}

Checksum: ast::token::Checksum = <left:@L> <star:TokStar> <checksum:TokInteger> <right:@R> =>? Ok(ast::token::Checksum {
    inner: checksum.parse::<u8>().map_err(|e| LexicalError::ParseIntError(e))?,
    span: ast::Span(left, right)
});

Field: ast::token::Field<'input> = {
    <left:@L> <letters:TokLetters> <value:TokInteger> <right:@R> =>? {
        Ok(ast::token::Field {
            letters,
            value: ast::token::Value::Integer(value.parse::<usize>().map_err(|e| LexicalError::ParseIntError(e))?),
            raw_value: vec![value],
            span: ast::Span(left, right)
        })
    },

    <left:@L> <letters:TokLetters> <neg:TokMinus> <value:TokInteger> <right:@R> =>? {
        Ok(ast::token::Field {
            letters,
            value: ast::token::Value::Rational(-value.parse::<Ratio<i64>>().map_err(|e| LexicalError::ParseRatioError(e))?),
            raw_value: vec!["-", value],
            span: ast::Span(left, right)
        })
    },

    <left:@L> <letters:TokLetters> <neg:TokMinus?> <lhs:TokInteger> <dot:TokDot> <rhs:TokInteger?> <right:@R> =>? {
        Ok(ast::token::Field {
            letters,
            value: ast::token::Value::Rational(lhs.parse::<Ratio<i64>>()
                .map_err(|e| LexicalError::ParseRatioError(e))
                .and_then(|lhs| if let Some(rhs_str) = rhs {
                    rhs_str.parse::<i64>()
                           .map(|rhs| Ratio::new(rhs, 10i64 * rhs_str.trim_start_matches('0').len() as i64))
                           .map(|rhs| lhs + rhs)
                           .map(|value| if neg.is_some() { -value } else { value })
                           .map_err(|e| LexicalError::ParseIntError(e))
                } else {
                    Ok(lhs)
                })?),
            raw_value: if neg.is_some() { vec!["-", lhs, ".", rhs.unwrap_or("")] } else { vec![".", rhs.unwrap_or("")] },
            span: ast::Span(left, right)
        })
    },

    <left:@L> <letters:TokLetters> <neg:TokMinus?> <dot:TokDot> <rhs_str:TokInteger> <right:@R> =>? {
        Ok(ast::token::Field {
            letters,
            value: ast::token::Value::Rational(rhs_str.parse::<i64>()
                .map(|rhs| Ratio::new(rhs, 10i64 * rhs_str.trim_start_matches('0').len() as i64))
                .map(|rhs| if neg.is_some() { -rhs } else { rhs })
                .map_err(|e| LexicalError::ParseIntError(e))?),
            raw_value: if neg.is_some() { vec!["-", ".", rhs_str] } else { vec![".", rhs_str] },
            span: ast::Span(left, right)
        })
    },

    <left:@L> <letters:TokLetters> <string:TokString> <right:@R> => ast::token::Field {
        letters,
        value: ast::token::Value::String(string),
        raw_value: vec![string],
        span: ast::Span(left, right)
    }
};

Comment: ast::token::Comment<'input> = <left:@L> <comment:TokComment> => ast::token::Comment {
    inner: comment,
    pos: left,
};

InlineComment: ast::token::InlineComment<'input> = <left:@L> <comment:TokInlineComment> => ast::token::InlineComment {
    inner: comment,
    pos: left,
};

Whitespace: ast::token::Whitespace<'input> = <left:@L> <whitespace:TokWhitespace> => ast::token::Whitespace {
    inner: whitespace,
    pos: left,
};

Line: ast::Line<'input> = <left:@L> <fields:(InlineComment* (Whitespace InlineComment*)* Field)*> <checksum:(InlineComment* (Whitespace InlineComment*)* Checksum)?> <comment:(InlineComment* (Whitespace InlineComment*)* Comment)?> <whitespace:((Whitespace InlineComment*)* Whitespace)?> <inline_comment:InlineComment*> <right:@R> => ast::Line {
    fields,
    checksum,
    comment,
    whitespace,
    inline_comment,
    span: ast::Span(left, right)
};

Newline: ast::token::Newline = <left:@L> TokNewline => ast::token::Newline { pos: left };

pub File: ast::File<'input> = {
    <lines:(Line Newline)*> <last_line:Line> => ast::File {
        lines,
        last_line: if last_line.fields.is_empty() && last_line.checksum.is_none() && last_line.comment.is_none() && last_line.inline_comment.is_empty() {
            None
        } else {
            Some(last_line)
        }
    },
};
